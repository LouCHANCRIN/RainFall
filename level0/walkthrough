We have a binary file. #readelf

There is a binary file when logging in.
When it is launched with no arguments it return a segfault, else it print "No !"

We get the assembly code with
$ gdb ./level0
(gdb) disassemble main


We can see that the first function call is atoi and it is followed by a comparison between 423 and a register (cmp $0x1a7,%eax).
Therefore we try to launch the binary with 423 as argument.
It opens a new shell.
We try the command 'ls' but we get a permission denied.
We try pwd and see we are in '/home/user/level0' and 'whoami' gives us 'level1' so we can assume there is a '/home/user/level1' directory.
We then go to that directory and type 'ls -la' and we can see a file named '.pass' that contain the flag.



   0x08048ec0 <+0>:     push   %ebp             # Add the ebp register to the stack. It is used to point at the top of the stack.
   0x08048ec1 <+1>:     mov    %esp,%ebp        # Copy ebp register to esp register
   0x08048ec3 <+3>:     and    $0xfffffff0,%esp # Binary and operation between esp register value and 0xfffffff0 (-16) to make it a multiple of 16
   0x08048ec6 <+6>:     sub    $0x20,%esp       # Substract esp value to 0x20 (32)
   0x08048ec9 <+9>:     mov    0xc(%ebp),%eax   # Copy eax register 0xc (12) bytes below the ebp register
   0x08048ecc <+12>:    add    $0x4,%eax        # Add eax value to 0x4 register
   0x08048ecf <+15>:    mov    (%eax),%eax
   0x08048ed1 <+17>:    mov    %eax,(%esp)
   0x08048ed4 <+20>:    call   0x8049710 <atoi> # Call to atoi
   0x08048ed9 <+25>:    cmp    $0x1a7,%eax      # Compare value == 423
   0x08048ede <+30>:    jne    0x8048f58 <main+152> # Condition jump if previous condition is true
   0x08048ee0 <+32>:    movl   $0x80c5348,(%esp)
   0x08048ee7 <+39>:    call   0x8050bf0 <strdup>   # Call strdup
   0x08048eec <+44>:    mov    %eax,0x10(%esp)
   0x08048ef0 <+48>:    movl   $0x0,0x14(%esp)
   0x08048ef8 <+56>:    call   0x8054680 <getegid>  # Call getegid
   0x08048efd <+61>:    mov    %eax,0x1c(%esp)
   0x08048f01 <+65>:    call   0x8054670 <geteuid>  # Call geteuid
   0x08048f06 <+70>:    mov    %eax,0x18(%esp)
   0x08048f0a <+74>:    mov    0x1c(%esp),%eax
   0x08048f0e <+78>:    mov    %eax,0x8(%esp)
   0x08048f12 <+82>:    mov    0x1c(%esp),%eax
   0x08048f16 <+86>:    mov    %eax,0x4(%esp)
   0x08048f1a <+90>:    mov    0x1c(%esp),%eax
   0x08048f1e <+94>:    mov    %eax,(%esp)
   0x08048f21 <+97>:    call   0x8054700 <setresgid> # Call setresgid
   0x08048f26 <+102>:   mov    0x18(%esp),%eax
   0x08048f2a <+106>:   mov    %eax,0x8(%esp)
   0x08048f2e <+110>:   mov    0x18(%esp),%eax
   0x08048f32 <+114>:   mov    %eax,0x4(%esp)
   0x08048f36 <+118>:   mov    0x18(%esp),%eax
   0x08048f3a <+122>:   mov    %eax,(%esp)
   0x08048f3d <+125>:   call   0x8054690 <setresuid> # Call setresuid
   0x08048f42 <+130>:   lea    0x10(%esp),%eax
   0x08048f46 <+134>:   mov    %eax,0x4(%esp)
   0x08048f4a <+138>:   movl   $0x80c5348,(%esp)     # Move if
   0x08048f51 <+145>:   call   0x8054640 <execv>     # Call execv
   0x08048f56 <+150>:   jmp    0x8048f80 <main+192>  # Jump further in the code
   0x08048f58 <+152>:   mov    0x80ee170,%eax
   0x08048f5d <+157>:   mov    %eax,%edx
   0x08048f5f <+159>:   mov    $0x80c5350,%eax
   0x08048f64 <+164>:   mov    %edx,0xc(%esp)
   0x08048f68 <+168>:   movl   $0x5,0x8(%esp)
   0x08048f70 <+176>:   movl   $0x1,0x4(%esp)
   0x08048f78 <+184>:   mov    %eax,(%esp)
   0x08048f7b <+187>:   call   0x804a230 <fwrite>    # Call fwrite
   0x08048f80 <+192>:   mov    $0x0,%eax
   0x08048f85 <+197>:   leave  # Free memory
   0x08048f86 <+198>:   ret    # Return





"
08048ec0 <main>:
 8048ec0:	55                   	push   %ebp                 
 8048ec1:	89 e5                	mov    %esp,%ebp            
 8048ec3:	83 e4 f0             	and    $0xfffffff0,%esp     
 8048ec6:	83 ec 20             	sub    $0x20,%esp           
 8048ec9:	8b 45 0c             	mov    0xc(%ebp),%eax       
 8048ecc:	83 c0 04             	add    $0x4,%eax            
 8048ecf:	8b 00                	mov    (%eax),%eax
 8048ed1:	89 04 24             	mov    %eax,(%esp)
 8048ed4:	e8 37 08 00 00       	call   8049710 <atoi>
 8048ed9:	3d a7 01 00 00       	cmp    $0x1a7,%eax
 8048ede:	75 78                	jne    8048f58 <main+0x98>
 8048ee0:	c7 04 24 48 53 0c 08 	movl   $0x80c5348,(%esp)
 8048ee7:	e8 04 7d 00 00       	call   8050bf0 <__strdup>
 8048eec:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048ef0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8048ef7:	00 
 8048ef8:	e8 83 b7 00 00       	call   8054680 <__getegid>
 8048efd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 8048f01:	e8 6a b7 00 00       	call   8054670 <__geteuid>
 8048f06:	89 44 24 18          	mov    %eax,0x18(%esp)
 8048f0a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8048f0e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048f12:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8048f16:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048f1a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8048f1e:	89 04 24             	mov    %eax,(%esp)
 8048f21:	e8 da b7 00 00       	call   8054700 <__setresgid>
 8048f26:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048f2a:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048f2e:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048f32:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048f36:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048f3a:	89 04 24             	mov    %eax,(%esp)
 8048f3d:	e8 4e b7 00 00       	call   8054690 <__setresuid>
 8048f42:	8d 44 24 10          	lea    0x10(%esp),%eax
 8048f46:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048f4a:	c7 04 24 48 53 0c 08 	movl   $0x80c5348,(%esp)
 8048f51:	e8 ea b6 00 00       	call   8054640 <execv>
 8048f56:	eb 28                	jmp    8048f80 <main+0xc0>
 8048f58:	a1 70 e1 0e 08       	mov    0x80ee170,%eax
 8048f5d:	89 c2                	mov    %eax,%edx
 8048f5f:	b8 50 53 0c 08       	mov    $0x80c5350,%eax
 8048f64:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048f68:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
 8048f6f:	00 
 8048f70:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8048f77:	00 
 8048f78:	89 04 24             	mov    %eax,(%esp)
 8048f7b:	e8 b0 12 00 00       	call   804a230 <_IO_fwrite>
 8048f80:	b8 00 00 00 00       	mov    $0x0,%eax
 8048f85:	c9                   	leave  
 8048f86:	c3                   	ret    
 8048f87:	90                   	nop
 8048f88:	90                   	nop
 8048f89:	90                   	nop
 8048f8a:	90                   	nop
 8048f8b:	90                   	nop
 8048f8c:	90                   	nop
 8048f8d:	90                   	nop
 8048f8e:	90                   	nop
 8048f8f:	90                   	nop
"
